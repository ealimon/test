<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Paste Processor – Column Drop + PPC Assist Filter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1220;
      --panel: #101827;
      --panel2: #0d1625;
      --text: #e6eef8;
      --muted: #9fb2c8;
      --accent: #4f76fd;
      --border: #223049;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; background: linear-gradient(180deg, #0a1020, #0b1220); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 20px;
    }
    .app { width: 100%; max-width: 1000px; background: linear-gradient(180deg, var(--panel), #0e1726);
      border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); overflow: hidden; }
    header { padding: 18px 20px; border-bottom: 1px solid var(--border);
      background: linear-gradient(90deg, rgba(79,118,253,0.15), rgba(56,189,248,0.15)); }
    header h1 { margin: 0 0 4px; font-size: 20px; }
    header p { margin: 0; color: var(--muted); font-size: 14px; }
    main { padding: 18px; display: grid; gap: 16px; grid-template-columns: 1.1fr 1fr; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }
    .card { background: linear-gradient(180deg, var(--panel), var(--panel2)); border: 1px solid var(--border);
      border-radius: 12px; padding: 14px; }
    .card h2 { margin: 0 0 10px; font-size: 16px; }
    textarea { width: 100%; min-height: 380px; background: #0a1326; color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
    .small { font-size: 12px; color: var(--muted); }
    .actions { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; }
    button, .btn {
      appearance: none; border: 1px solid var(--border); color: var(--text); font-weight: 600;
      background: linear-gradient(180deg, #16223a, #121b2f); padding: 10px 14px; border-radius: 10px; cursor: pointer;
    }
    button:hover, .btn:hover { border-color: #345; background: linear-gradient(180deg, #1a2947, #15223b); }
    button.primary { background: linear-gradient(180deg, #2a4ff0, #2244d4); border-color: #3050ff; }
    button.primary:hover { background: linear-gradient(180deg, #3358ff, #2649db); }
    button[disabled] { opacity: 0.6; cursor: not-allowed; filter: grayscale(0.2); }
    select { background: #0f1830; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 8px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .pill { display: inline-flex; gap: 8px; align-items: center; background: rgba(56,189,248,0.12); border: 1px solid rgba(56,189,248,0.35);
      color: #c3e9ff; padding: 6px 10px; border-radius: 999px; font-size: 13px; font-weight: 600; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .status { margin-top: 10px; font-size: 13px; line-height: 1.45; background: #0d1526; border: 1px solid var(--border);
      border-radius: 8px; padding: 10px 12px; color: var(--muted); max-height: 240px; overflow: auto; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CSV Paste Processor</h1>
      <p>Paste your CSV below. The tool drops columns H, I, J, K, L, M, N, O, P, Q, U, V, W, X, Y, AA and applies PPC Assist filtering.</p>
    </header>
    <main>
      <section class="card">
        <h2>1) Paste your CSV</h2>
        <textarea id="csv-input" placeholder="Paste CSV text here..."></textarea>
        <div class="actions">
          <button id="process-btn" class="primary">Process & Prepare Download</button>
          <a id="download-link" class="btn" style="display:none" download>Download Cleaned CSV</a>
          <button id="reset-btn">Reset</button>
        </div>
        <div id="status" class="status">Waiting for CSV text…</div>
      </section>
      <section class="card">
        <h2>2) Settings</h2>
        <div class="row">
          <span class="pill">Drop letters <span class="mono">H, I, J, K, L, M, N, O, P, Q, U, V, W, X, Y, AA</span></span>
        </div>
        <div class="row">
          <span>When PPC Assist would be deleted, filter first and:</span>
          <select id="ppc-first-mode">
            <option value="remove" selected>Remove rows where PPC Assist == "Y"</option>
            <option value="keep">Keep rows where PPC Assist == "Y"</option>
          </select>
        </div>
        <div class="small">
          Otherwise (when PPC Assist remains), columns are dropped first, then rows are kept where PPC Assist == "Y".
          The PPC Assist header is matched by exact text (trimmed). If not found, it will fall back to column Z before dropping.
        </div>
      </section>
    </main>
  </div>  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js" referrerpolicy="no-referrer"></script>  <script>
    // Configuration
    const LETTERS_TO_DROP = ['H','I','J','K','L','M','N','O','P','Q','U','V','W','X','Y','AA'];
    const FILTER_HEADER_NAME = 'PPC Assist';
    const FILTER_VALUE = 'Y';
    const PPC_LETTER_FALLBACK = 'Z'; // Used pre-drop if header not found

    function excelColToZeroIndex(col) {
      let idx = 0;
      for (const ch of col.toUpperCase()) {
        const code = ch.charCodeAt(0);
        if (code < 65 || code > 90) throw new Error('Invalid column letter: ' + col);
        idx = idx * 26 + (code - 64);
      }
      return idx - 1;
    }
    const DROP_INDICES_0 = LETTERS_TO_DROP.map(excelColToZeroIndex);

    const inputEl = document.getElementById('csv-input');
    const statusEl = document.getElementById('status');
    const processBtn = document.getElementById('process-btn');
    const resetBtn = document.getElementById('reset-btn');
    const downloadLink = document.getElementById('download-link');
    const modeSelect = document.getElementById('ppc-first-mode');

    let cleanedCsvBlobUrl = null;

    function setStatus(msg, append=false) {
      statusEl.textContent = append ? (statusEl.textContent + '\\n' + msg) : msg;
    }

    function resetState() {
      inputEl.value = '';
      setStatus('Waiting for CSV text…');
      if (cleanedCsvBlobUrl) { URL.revokeObjectURL(cleanedCsvBlobUrl); cleanedCsvBlobUrl = null; }
      downloadLink.style.display = 'none';
      downloadLink.removeAttribute('href');
      downloadLink.removeAttribute('download');
    }

    resetBtn.addEventListener('click', resetState);

    function trimOrEmpty(v) { return (v == null) ? '' : String(v).trim(); }

    function findHeaderIndex(headerRow, name) {
      const target = trimOrEmpty(name);
      for (let i = 0; i < headerRow.length; i++) {
        if (trimOrEmpty(headerRow[i]) === target) return i;
      }
      return -1;
    }

    function dropColumns(rows, dropIndices0) {
      return rows.map(row => {
        if (!Array.isArray(row)) return row;
        const dropSet = new Set(dropIndices0.filter(i => i >= 0 && i < row.length));
        return row.filter((_, idx) => !dropSet.has(idx));
      });
    }

    function filterRows(rows, colIdx, value, mode) {
      // mode: 'keep' -> keep rows where cell == value, 'remove' -> keep rows where cell != value
      if (rows.length === 0 || colIdx < 0) return rows;
      const header = rows[0];
      const out = [header];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (!Array.isArray(row)) continue;
        const cellVal = trimOrEmpty(row[colIdx]);
        const match = (cellVal === value);
        if ((mode === 'keep' && match) || (mode === 'remove' && !match)) out.push(row);
      }
      return out;
    }

    function removeCompletelyEmptyTrailingRows(rows) {
      let end = rows.length - 1;
      while (end >= 1) {
        const row = rows[end];
        const nonEmpty = Array.isArray(row) && row.some(v => trimOrEmpty(v) !== '');
        if (nonEmpty) break;
        end--;
      }
      return rows.slice(0, end + 1);
    }

    processBtn.addEventListener('click', () => {
      const text = inputEl.value || '';
      if (!text.trim()) {
        setStatus('Please paste CSV content first.');
        return;
      }
      setStatus('Parsing CSV…');
      try {
        const parsed = Papa.parse(text, {
          dynamicTyping: false,
          skipEmptyLines: 'greedy'
        });

        if (parsed.errors && parsed.errors.length) {
          setStatus(
            `CSV parse warnings: ${parsed.errors.length}\n` +
            parsed.errors.slice(0,3).map(e => `- Row ${e.row}: ${e.message}`).join('\n'),
            true
          );
        }

        let rows = parsed.data;
        if (!Array.isArray(rows) || rows.length === 0 || !Array.isArray(rows[0])) {
          setStatus('No usable rows found in CSV.');
          return;
        }

        const originalRowCount = rows.length;
        const header = rows[0];

        // Determine PPC Assist column before dropping
        let ppcIdxOriginal = findHeaderIndex(header, FILTER_HEADER_NAME);
        if (ppcIdxOriginal === -1 && PPC_LETTER_FALLBACK) {
          const fb = excelColToZeroIndex(PPC_LETTER_FALLBACK);
          if (fb >= 0 && fb < header.length) {
            ppcIdxOriginal = fb;
            setStatus(`Header "${FILTER_HEADER_NAME}" not found; using fallback column ${PPC_LETTER_FALLBACK} (index ${fb}).`, true);
          } else {
            setStatus(`Header "${FILTER_HEADER_NAME}" not found, and fallback column ${PPC_LETTER_FALLBACK} is out of range.`, true);
          }
        }

        const willDropPpc = ppcIdxOriginal >= 0 && DROP_INDICES_0.includes(ppcIdxOriginal);
        const firstMode = modeSelect.value; // 'remove' or 'keep'

        if (ppcIdxOriginal >= 0 && willDropPpc) {
          // Filter first using original index, according to selected mode
          const modeDesc = firstMode === 'remove'
            ? 'Removing rows where PPC Assist == "Y" before dropping columns…'
            : 'Keeping rows where PPC Assist == "Y" before dropping columns…';
          setStatus(modeDesc, true);
          rows = filterRows(rows, ppcIdxOriginal, FILTER_VALUE, firstMode);
          rows = dropColumns(rows, DROP_INDICES_0);
        } else {
          // Drop columns first, then keep only rows where PPC Assist == 'Y'
          rows = dropColumns(rows, DROP_INDICES_0);
          const newHeader = rows[0];
          const ppcIdxAfter = findHeaderIndex(newHeader, FILTER_HEADER_NAME);
          if (ppcIdxAfter === -1) {
            setStatus('Warning: "PPC Assist" column not found after dropping columns; no row filtering applied.', true);
          } else {
            setStatus('Keeping rows where PPC Assist == "Y"…', true);
            rows = filterRows(rows, ppcIdxAfter, FILTER_VALUE, 'keep');
          }
        }

        rows = removeCompletelyEmptyTrailingRows(rows);

        const keptRows = rows.length;
        setStatus(`Rows before: ${originalRowCount} | after: ${keptRows}`, true);

        const csvText = Papa.unparse(rows);
        const BOM = new Uint8Array([0xEF, 0xBB, 0xBF]); // Excel-friendly
        const blob = new Blob([BOM, csvText], { type: 'text/csv;charset=utf-8' });

        if (cleanedCsvBlobUrl) URL.revokeObjectURL(cleanedCsvBlobUrl);
        cleanedCsvBlobUrl = URL.createObjectURL(blob);

        downloadLink.href = cleanedCsvBlobUrl;
        downloadLink.download = 'cleaned-filtered.csv';
        downloadLink.style.display = 'inline-flex';

        setStatus('Ready! Click "Download Cleaned CSV" to save your file.', true);
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + (err && err.message ? err.message : String(err)));
      }
    });
  </script></body>
</html>
