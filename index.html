/**
Google Sheets automation:


Deletes columns by Excel letters (e.g., H, AA)




Sorts the data (by letters or header names)




Colors the header and/or specific data rows



Setup:


Extensions > Apps Script > paste this file (Code.gs)




Edit CONFIG as needed




Refresh the sheet; use menu: Process > Cleanup & Sort
*/


const CONFIG = {
// Leave blank to use the active sheet, or specify an exact name:
sheetName: "",// Columns to delete by Excel letters (current positions).
// Note: This acts on the current sheet layout. Run once per imported CSV.
dropColumnsLetters: ["H","I","J","K","L","M","N","O","P","Q","U","V","W","X","Y","AA"],// Whether the first row is a header row.
hasHeader: true,// Sorting instructions (in priority order).
// You can use column letters (e.g., 'B') or header names (e.g., 'Date').
// order: 'asc' or 'desc'
sortBy: [
// { col: "B", order: "asc" },
// { col: "Date", order: "desc" },
],// Appearance
highlight: {
header: true,           // color the header row (if hasHeader)
rows: [],               // data rows to color, 1-based (e.g., [1,3] colors first and third data rows)
color: "#FFF2CC"        // hex color
},// Clear all existing backgrounds before re-coloring
clearAllBackgrounds: true,// Freeze the header row for convenience
freezeHeader: true
};function onOpen() {
SpreadsheetApp.getUi()
.createMenu("Process")
.addItem("Cleanup & Sort", "runCleanup")
.addToUi();
}function runCleanup() {
const ss = SpreadsheetApp.getActive();
const sheet = CONFIG.sheetName
? ss.getSheetByName(CONFIG.sheetName)
: ss.getActiveSheet();if (!sheet) {
throw new Error("Sheet not found: " + CONFIG.sheetName);
}// 1) Delete requested columns (right-to-left to avoid shifting)
if (CONFIG.dropColumnsLetters && CONFIG.dropColumnsLetters.length) {
removeColumnsByLetters(sheet, CONFIG.dropColumnsLetters);
}// 2) Sort the data range (excluding header, if present)
const lastRow = sheet.getLastRow();
const lastCol = sheet.getLastColumn();
if (lastRow === 0 || lastCol === 0) {
SpreadsheetApp.getUi().alert("Nothing to process: the sheet is empty.");
return;
}if (CONFIG.sortBy && CONFIG.sortBy.length) {
const sortSpecs = buildSortSpecs(sheet, CONFIG.sortBy, CONFIG.hasHeader);
const startRow = CONFIG.hasHeader ? 2 : 1;
const numRows = Math.max(0, lastRow - startRow + 1);
if (numRows > 1) {
sheet.getRange(startRow, 1, numRows, lastCol).sort(sortSpecs);
}
}// 3) Background coloring
if (CONFIG.clearAllBackgrounds) {
sheet.getRange(1, 1, lastRow, lastCol).setBackground(null);
}if (CONFIG.hasHeader && CONFIG.highlight && CONFIG.highlight.header) {
const color = CONFIG.highlight.color || "#FFF2CC";
sheet.getRange(1, 1, 1, lastCol).setBackground(color);
}if (CONFIG.highlight && Array.isArray(CONFIG.highlight.rows) && CONFIG.highlight.rows.length) {
const color = CONFIG.highlight.color || "#FFF2CC";
const startRow = CONFIG.hasHeader ? 2 : 1;
const uniqueRows = Array.from(new Set(CONFIG.highlight.rows.filter(r => r >= 1))).sort((a,b) => a - b);
uniqueRows.forEach(r => {
const rowIndex = startRow + (r - 1);
if (rowIndex <= sheet.getLastRow()) {
sheet.getRange(rowIndex, 1, 1, sheet.getLastColumn()).setBackground(color);
}
});
}if (CONFIG.freezeHeader && CONFIG.hasHeader) {
sheet.setFrozenRows(1);
}SpreadsheetApp.getUi().alert("Done: columns removed, data sorted, and highlighting applied.");
}// Helpersfunction removeColumnsByLetters(sheet, letters) {
// Convert to 1-based column indices, keep only those that exist, and delete right-to-left
const lastCol = sheet.getLastColumn();
const indices = letters
.map(letterToIndex)
.filter(n => n >= 1 && n <= lastCol)
.sort((a, b) => b - a);
indices.forEach(idx => sheet.deleteColumns(idx, 1));
}function buildSortSpecs(sheet, sortBy, hasHeader) {
const specs = [];
const lastCol = sheet.getLastColumn();
const header = hasHeader
? sheet.getRange(1, 1, 1, lastCol).getValues()[0]
: null;sortBy.forEach(item => {
const token = item.col;
let colIndex;if (typeof token === "number") {
  colIndex = token; // 1-based column
} else if (typeof token === "string") {
  if (/^[A-Za-z]+$/.test(token)) {
    colIndex = letterToIndex(token);
  } else if (header) {
    const idx = header.indexOf(token);
    if (idx === -1) throw new Error("Sort column not found in header: " + token);
    colIndex = idx + 1;
  } else {
    throw new Error("Cannot resolve sort column (no header to match): " + token);
  }
} else {
  throw new Error("Invalid sort column token: " + token);
}

specs.push({
  column: colIndex,
  ascending: !String(item.order || "asc").toLowerCase().startsWith("d")
});
});return specs;
}function letterToIndex(s) {
const str = String(s).trim().toUpperCase();
if (!/^[A-Z]+$/.test(str)) throw new Error("Invalid column letter: " + s);
let n = 0;
for (let i = 0; i < str.length; i++) {
n = n * 26 + (str.charCodeAt(i) - 64); // 'A' -> 1
}
return n; // 1-based
}
