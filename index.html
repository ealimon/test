<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CSV Cleaner (Offline) – Filter Rows First (Blank Z) Then Drop Columns</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b1220; --panel: #101827; --panel-bright: #1a2233; --text: #e6eef8; --muted: #9fb2c8;
      --accent: #4f76fd; --ok: #22c55e; --warn: #f59e0b; --err: #ef4444; --border: #223049;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg, #0a1020, #0b1220); color: var(--text); min-height: 100vh;
      display: flex; align-items: center; justify-content: center; padding: 24px; }
    .app { width: 100%; max-width: 980px; background: linear-gradient(180deg, var(--panel), #0e1726);
      border: 1px solid var(--border); border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); overflow: hidden; }
    header { padding: 20px 24px; background: linear-gradient(90deg, rgba(79,118,253,0.15), rgba(56,189,248,0.15)); border-bottom: 1px solid var(--border); }
    header h1 { margin: 0 0 6px; font-size: 20px; font-weight: 700; }
    header p { margin: 0; color: var(--muted); font-size: 14px; }
    main { padding: 24px; }
    .grid { display: grid; grid-template-columns: 1.2fr 1fr; gap: 20px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .card { background: linear-gradient(180deg, var(--panel), #0d1625); border: 1px solid var(--border); border-radius: 12px; padding: 16px; }
    .card h2 { margin: 0 0 10px; font-size: 16px; font-weight: 700; }.dropzone { border: 2px dashed #2a3b5e; border-radius: 12px; padding: 22px; text-align: center; background: rgba(32,44,72,0.35); cursor: pointer; }
.dropzone.dragover { border-color: var(--accent); background: rgba(79,118,253,0.12); }
.dropzone input[type="file"] { display: none; }
.dz-title { font-weight: 700; margin-bottom: 6px; }
.dz-sub { font-size: 13px; color: var(--muted); }

.fileinfo { margin-top: 10px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
.file-label { color: var(--muted); font-size: 13px; }
.file-name { font-weight: 700; }
.file-size { color: var(--muted); font-size: 13px; }

.options { margin-top: 10px; font-size: 14px; display: grid; gap: 8px; }
.options label { display: inline-flex; align-items: center; gap: 8px; cursor: pointer; }
.options input[type="checkbox"], .options select { transform: translateY(1px); }
select { background: #0f1830; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 8px; }

.progress-wrap { margin-top: 12px; }
.progress-label { font-size: 13px; color: var(--muted); margin-bottom: 6px; }
.progress { position: relative; height: 10px; background: #0f1930; border: 1px solid var(--border); border-radius: 999px; overflow: hidden; }
.progress-bar { position: absolute; left: 0; top: 0; bottom: 0; width: 0%; background: linear-gradient(90deg, #4f76fd, #38bdf8); transition: width 0.2s ease; }

.status { margin-top: 12px; font-size: 14px; line-height: 1.45; background: #0d1526; border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px; color: var(--muted); max-height: 260px; overflow: auto; white-space: pre-wrap; }

.actions { display: flex; gap: 10px; margin-top: 14px; flex-wrap: wrap; }
button, .btn { appearance: none; border: 1px solid var(--border); background: linear-gradient(180deg, #16223a, #121b2f);
  color: var(--text); font-weight: 600; padding: 10px 14px; border-radius: 10px; cursor: pointer; }
button.primary { background: linear-gradient(180deg, #2a4ff0, #2244d4); border-color: #3050ff; }
button.success { background: linear-gradient(180deg, #1e8449, #176d3b); border-color: #29a35a; }
button[disabled] { opacity: 0.6; cursor: not-allowed; filter: grayscale(0.2); }

.pill { display: inline-flex; align-items: center; gap: 8px; background: rgba(56,189,248,0.12); border: 1px solid rgba(56,189,248,0.35);
  color: #c3e9ff; padding: 6px 10px; border-radius: 999px; font-size: 13px; font-weight: 600; }
.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
.small { font-size: 12px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>CSV Cleaner (Offline) – Filter Rows First</h1>
      <p>Filters rows by PPC Assist and blank column Z, then removes columns H, I, J, K, L, M, N, O, P, Q, U, V, W, X, Y, AA.</p>
    </header>
    <main>
      <div class="grid">
        <section class="card">
          <h2>1) Upload CSV</h2>
          <div id="dropzone" class="dropzone" tabindex="0" role="button" aria-label="Upload CSV">
            <div class="dz-title">Drop your CSV here</div>
            <div class="dz-sub">or click to select a file</div>
            <input id="file-input" type="file" accept=".csv,text/csv" />
          </div>      <div class="fileinfo" aria-live="polite">
        <div class="file-label">Selected file:</div>
        <div id="file-name" class="file-name">None</div>
        <div id="file-size" class="file-size"></div>
      </div>

      <div class="options">
        <label>
          <input id="remove-blank-z" type="checkbox" checked />
          Remove rows where column Z is blank (whitespace counts as blank)
        </label>
        <label>
          <input id="remove-blanks-ppc" type="checkbox" checked />
          Remove rows where PPC Assist is blank
        </label>
        <label>
          PPC Assist filter:
          <select id="filter-mode">
            <option value="remove">Remove rows where PPC Assist == "Y"</option>
            <option value="keep" selected>Keep only rows where PPC Assist == "Y"</option>
          </select>
        </label>
        <div class="small">Order is always: filter rows first (Z blank removal, PPC blank removal, PPC Y rule), then drop columns.</div>
      </div>

      <div class="progress-wrap">
        <div class="progress-label" id="progress-label">Idle</div>
        <div class="progress"><div id="progress-bar" class="progress-bar"></div></div>
      </div>

      <div class="status" id="status">Waiting for file…</div>
      <div class="actions">
        <button id="process-btn" class="primary" disabled>Process & Prepare Download</button>
        <a id="download-link" class="btn success" style="display:none" download>Download Cleaned CSV</a>
        <button id="reset-btn">Reset</button>
      </div>
    </section>

    <section class="card">
      <h2>2) Rules</h2>
      <div class="small">
        <div class="pill">Drop letters: <span class="mono">H, I, J, K, L, M, N, O, P, Q, U, V, W, X, Y, AA</span></div>
        <p>
          Filtering looks for the header "PPC Assist". If not found, it falls back to the physical column Z for PPC filtering; column Z blank removal always uses the physical Z column before any columns are removed.
        </p>
      </div>
    </section>
  </div>
</main>
  </div>  <script>
    // Lightweight CSV parser/unparser
    function parseCSV(text, delimiter = ',') {
      text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      const rows = [];
      let row = [], field = '', inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const ch = text[i];
        if (inQuotes) {
          if (ch === '"') {
            if (i + 1 < text.length && text[i + 1] === '"') { field += '"'; i++; }
            else { inQuotes = false; }
          } else { field += ch; }
        } else {
          if (ch === '"') inQuotes = true;
          else if (ch === delimiter) { row.push(field); field = ''; }
          else if (ch === '\n') { row.push(field); rows.push(row); row = []; field = ''; }
          else { field += ch; }
        }
      }
      row.push(field); rows.push(row);
      while (rows.length > 1 && rows[rows.length - 1].every(v => String(v || '').trim() === '')) rows.pop();
      return rows;
    }
    function unparseCSV(rows, delimiter = ',') {
      const esc = (v) => {
        const s = v == null ? '' : String(v);
        return (s.includes('"') || s.includes(delimiter) || s.includes('\n')) ? '"' + s.replace(/"/g, '""') + '"' : s;
      };
      return rows.map(r => r.map(esc).join(delimiter)).join('\n');
    }

    // Config
    const LETTERS_TO_DROP = ['H','I','J','K','L','M','N','O','P','Q','U','V','W','X','Y','AA'];
    const FILTER_HEADER_NAME = 'PPC Assist';
    const FILTER_VALUE = 'Y';
    const PPC_LETTER_FALLBACK = 'Z'; // fallback if header not found
    const Z_INDEX_0 = letterToZeroIndex('Z'); // physical column Z index before dropping columns

    function letterToZeroIndex(col) {
      let idx = 0;
      for (const ch of col.toUpperCase()) {
        const code = ch.charCodeAt(0);
        if (code < 65 || code > 90) throw new Error('Invalid column letter: ' + col);
        idx = idx * 26 + (code - 64);
      }
      return idx - 1; // 0-based
    }
    const DROP_INDICES_0 = LETTERS_TO_DROP.map(letterToZeroIndex);

    // UI helpers
    const statusEl = document.getElementById('status');
    const progressBar = document.getElementById('progress-bar');
    const progressLabel = document.getElementById('progress-label');
    const fileNameEl = document.getElementById('file-name');
    const fileSizeEl = document.getElementById('file-size');
    const filterModeEl = document.getElementById('filter-mode');
    const removeBlanksPpcEl = document.getElementById('remove-blanks-ppc');
    const removeBlankZEl = document.getElementById('remove-blank-z');

    function logStatus(msg) {
      statusEl.textContent = statusEl.textContent ? (statusEl.textContent + '\n' + msg) : msg;
      progressLabel.textContent = msg;
    }
    function setProgress(pct) {
      const clamped = Math.max(0, Math.min(100, Math.round(pct)));
      progressBar.style.width = clamped + '%';
    }
    function trimOrEmpty(v) { return (v == null) ? '' : String(v).trim(); }
    function findHeaderIndex(headerRow, name) {
      const target = trimOrEmpty(name);
      for (let i = 0; i < headerRow.length; i++) {
        if (trimOrEmpty(headerRow[i]) === target) return i;
      }
      return -1;
    }
    function dropColumns(rows, dropIndices0) {
      return rows.map(row => {
        const dropSet = new Set(dropIndices0.filter(i => i >= 0 && i < row.length));
        const out = [];
        for (let i = 0; i < row.length; i++) if (!dropSet.has(i)) out.push(row[i]);
        return out;
      });
    }
    function filterRowsKeepEquals(rows, colIdx0, value) {
      if (rows.length === 0 || colIdx0 < 0) return rows;
      const out = [rows[0]];
      for (let r = 1; r < rows.length; r++) if (trimOrEmpty(rows[r][colIdx0]) === value) out.push(rows[r]);
      return out;
    }
    function filterRowsRemoveEquals(rows, colIdx0, value) {
      if (rows.length === 0 || colIdx0 < 0) return rows;
      const out = [rows[0]];
      for (let r = 1; r < rows.length; r++) if (trimOrEmpty(rows[r][colIdx0]) !== value) out.push(rows[r]);
      return out;
    }
    function filterRowsRemoveBlankAtIndex(rows, colIdx0) {
      if (rows.length === 0 || colIdx0 < 0) return rows;
      const out = [rows[0]];
      for (let r = 1; r < rows.length; r++) if (trimOrEmpty(rows[r][colIdx0]) !== '') out.push(rows[r]);
      return out;
    }
    function removeCompletelyEmptyTrailingRows(rows) {
      let end = rows.length - 1;
      while (end >= 1) {
        const row = rows[end];
        const nonEmpty = row.some(v => trimOrEmpty(v) !== '');
        if (nonEmpty) break;
        end--;
      }
      return rows.slice(0, end + 1);
    }

    // UI wiring
    const dz = document.getElementById('dropzone');
    const fileInput = document.getElementById('file-input');
    const processBtn = document.getElementById('process-btn');
    const downloadLink = document.getElementById('download-link');
    const resetBtn = document.getElementById('reset-btn');

    let selectedFile = null;
    let cleanedCsvBlobUrl = null;

    function formatSize(bytes) {
      if (!Number.isFinite(bytes)) return '';
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${(bytes/1024).toFixed(1)} KB`;
      return `${(bytes/(1024*1024)).toFixed(1)} MB`;
    }
    function resetState() {
      selectedFile = null;
      if (cleanedCsvBlobUrl) { URL.revokeObjectURL(cleanedCsvBlobUrl); cleanedCsvBlobUrl = null; }
      fileInput.value = '';
      processBtn.disabled = true;
      downloadLink.style.display = 'none';
      downloadLink.removeAttribute('href');
      downloadLink.removeAttribute('download');
      statusEl.textContent = 'Waiting for file…';
      progressLabel.textContent = 'Idle';
      setProgress(0);
      fileNameEl.textContent = 'None';
      fileSizeEl.textContent = '';
    }
    function handleFiles(files) {
      if (!files || !files.length) return;
      const file = files[0];
      const name = (file && file.name) ? file.name : 'input.csv';
      if (!name.toLowerCase().endsWith('.csv')) {
        statusEl.textContent = 'Please select a .csv file.';
        fileNameEl.textContent = 'None';
        fileSizeEl.textContent = '';
        return;
      }
      selectedFile = file;
      fileNameEl.textContent = name;
      fileSizeEl.textContent = `(${formatSize(file.size)})`;
      statusEl.textContent = `Selected: ${name} ${fileSizeEl.textContent}`;
      progressLabel.textContent = 'Ready';
      setProgress(0);
      processBtn.disabled = false;
      downloadLink.style.display = 'none';
    }

    dz.addEventListener('click', () => fileInput.click());
    dz.addEventListener('keypress', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); }});
    dz.addEventListener('dragover', (e) => { e.preventDefault(); dz.classList.add('dragover'); });
    dz.addEventListener('dragleave', () => dz.classList.remove('dragover'));
    dz.addEventListener('drop', (e) => { e.preventDefault(); dz.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
    fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
    resetBtn.addEventListener('click', resetState);

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    processBtn.addEventListener('click', async () => {
      if (!selectedFile) return;
      processBtn.disabled = true;
      setProgress(0);
      statusEl.textContent = '';

      try {
        logStatus('Reading file…'); setProgress(10);
        const text = await selectedFile.text();
        await sleep(150);

        logStatus('Parsing CSV…'); setProgress(25);
        let rows = parseCSV(text, ',');
        await sleep(150);

        if (!Array.isArray(rows) || rows.length === 0 || !Array.isArray(rows[0])) {
          logStatus('No usable rows found in CSV.');
          processBtn.disabled = false;
          return;
        }
        const originalRowCount = rows.length;

        logStatus('Analyzing headers…'); setProgress(40);
        const header = rows[0];

        // Resolve PPC Assist index: header name first, then fallback to physical Z
        let ppcIdx = findHeaderIndex(header, FILTER_HEADER_NAME);
        if (ppcIdx === -1) {
          if (Z_INDEX_0 >= 0 && Z_INDEX_0 < header.length) {
            ppcIdx = Z_INDEX_0;
            logStatus(`Header "${FILTER_HEADER_NAME}" not found; using fallback column Z (index ${Z_INDEX_0}).`);
          } else {
            logStatus(`Header "${FILTER_HEADER_NAME}" not found, and column Z is out of range. PPC filtering will be skipped.`);
          }
        }
        await sleep(120);

        // Always filter rows first
        const removeBlankZ = !!removeBlankZEl.checked;
        if (removeBlankZ) {
          if (Z_INDEX_0 >= 0 && Z_INDEX_0 < header.length) {
            logStatus('Removing rows where column Z is blank…'); setProgress(50);
            rows = filterRowsRemoveBlankAtIndex(rows, Z_INDEX_0);
            await sleep(120);
          } else {
            logStatus('Column Z is out of range; cannot remove rows with blank Z.');
          }
        }

        const removePpcBlanks = !!removeBlanksPpcEl.checked;
        if (removePpcBlanks && ppcIdx >= 0) {
          logStatus('Removing rows where PPC Assist is blank…'); setProgress(57);
          rows = filterRowsRemoveBlankAtIndex(rows, ppcIdx);
          await sleep(120);
        }

        const mode = filterModeEl.value; // 'remove' or 'keep'
        if (ppcIdx >= 0) {
          if (mode === 'remove') {
            logStatus('Removing rows where PPC Assist == "Y"…'); setProgress(64);
            rows = filterRowsRemoveEquals(rows, ppcIdx, FILTER_VALUE);
          } else {
            logStatus('Keeping only rows where PPC Assist == "Y"…'); setProgress(64);
            rows = filterRowsKeepEquals(rows, ppcIdx, FILTER_VALUE);
          }
          await sleep(120);
        }

        // Drop columns after filtering
        logStatus('Dropping specified columns…'); setProgress(75);
        rows = dropColumns(rows, DROP_INDICES_0);
        await sleep(120);

        // Cleanup and output
        logStatus('Removing empty trailing rows…'); setProgress(85);
        rows = removeCompletelyEmptyTrailingRows(rows);
        await sleep(120);

        logStatus('Preparing download…'); setProgress(95);
        const csvText = unparseCSV(rows, ',');
        const BOM = new Uint8Array([0xEF, 0xBB, 0xBF]); // Excel-friendly
        const blob = new Blob([BOM, csvText], { type: 'text/csv;charset=utf-8' });

        if (cleanedCsvBlobUrl) URL.revokeObjectURL(cleanedCsvBlobUrl);
        cleanedCsvBlobUrl = URL.createObjectURL(blob);

        const keptRows = rows.length;
        logStatus(`Rows before: ${originalRowCount} | after: ${keptRows}`);
        setProgress(100);

        const baseName = selectedFile.name || 'output.csv';
        downloadLink.href = cleanedCsvBlobUrl;
        downloadLink.download = 'cleaned-filtered-' + baseName;
        downloadLink.textContent = `Download Cleaned CSV (cleaned-filtered-${baseName})`;
        downloadLink.style.display = 'inline-flex';

        logStatus('Ready! Click "Download Cleaned CSV" to save your file.');
      } catch (err) {
        console.error(err);
        logStatus('Error: ' + (err && err.message ? err.message : String(err)));
      } finally {
        processBtn.disabled = false;
      }
    });

    // Initialize
    resetState();
  </script></body>
</html>
